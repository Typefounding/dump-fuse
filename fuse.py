#FLM: Dump or Fuse
# Version 2.0
# 
# This script offers will take in the data generated by the dump.py script
# and will rebuild the components based on the data taken from the text file.
# The script offers the ability to both dump the data and fuse the data into the
# current font.
#
# Fuse
# ----
# Will ask for a dump file and will then rebuild the font's componets from the
# dump file data. Offers the option to mark changed glyphs, and create backup
# glyphs of any changed glyphs, labeled by glyph name + .bkup as the backup
# glyph name.
#
# Dump
# ----
# Will look through a font and write out a text file that lists any glyph with a
# component(s), one glyph per line of the file. On each line, the script writes
# the glyph name, the width of the glyph, and then each component name and x, y
# offset for that compnent. These values are all semicolon seperated.
#
# Examples:
# Agrave;587.0;A;0;0;grave;70;0
# Aringacute;587.0;A;0;0;ring;155;139;acute;155;312
#
# This script was originally written in 2006 for John Hudson at Tiro Typeworks
#
# Version 2.0: License changed from GPL to MIT, tested and modififed to work in 
#              Robofont by adding a new TwoChecksDK class, a passing of the user
#              selected value for saving a backup into the make glyph function
#              added, and put on Github.
#
# ---------------------
# The MIT License (MIT)
# 
# Copyright (c) 2015 Typefounding
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.


#Imports
from robofab.world import CurrentFont, RGlyph
from robofab.pens.digestPen import DigestPointPen
from robofab.interface.all.dialogs import PutFile, GetFile, Message, OneList, TwoChecks, AskYesNoCancel, ProgressBar

#Functions
"""
getDataFile opens a semi-colon seperated file of the format:
glyph name;glyph advance width;first component name;glyph component x-position;glyph component y-position
The method takes in a message for the open file dialog.
It returns a list of the glyphs in this format:
(glyphname, width, [(component, x-position, y-position)]
"""
def getDataFile(message):
    #List of glyphs in semi-colon seperated file
    importedGlyphList = []
    
    #Get file
    filePath = GetFile(message)
    
    if filePath is None:
        return None
    
    else:
        file = open(filePath, 'r')
        for line in file:
            # Split line at semi-colon
            rawData = line.split(';')
            
            # First bit is the glyph name
            finalName = rawData[0]
            # Second bit is the advance width
            width = int(rawData[1])
            
            # Figure out how many components are in a glyph
            numberOfComponents = (len(rawData)-2) / 3
            componentList = []
            
            # Build component list
            count = 0
            while count < numberOfComponents:
                startIndex = 2 + (3 * count)
                componentList.append((rawData[startIndex], int(rawData[startIndex+1]), int(rawData[startIndex+2])))
                count = count+1
            importedGlyphList.append((finalName, width, componentList))
        file.close()
        return importedGlyphList

"""
makeGlyph takes in a list of of glyphs, a font object, a message for the progress bar, and a mark value.
It also pops up a helpful progress bar, because things are better with progress bars.
"""
def makeGlyph(glyphList, font, message, mark, saveBackup):
    # Initialize the progress bar
    tickCount = len(glyphList)
    bar = ProgressBar(message, tickCount)
    tick = 0
    
    for item in glyphList:
        glyphName, advanceWidth, components = item
        
        # If the font has the glyph, lots of checking is required to see if changes have been made
        if font.has_key(glyphName):
            glyph = font[glyphName]
            
            #Build new glyph for comparisons
            newGlyph = RGlyph()
            count = 0
            while count < len(components):
                component, x, y = components[count]
                newGlyph.appendComponent(component, offset=(x,y))
                count = count + 1
            newGlyph.width = advanceWidth
            
            # Make digest of the new glyph
            pointPen = DigestPointPen()
            newGlyph.drawPoints(pointPen)
            newDigest = pointPen.getDigest()
            
            # Make digest of the old glyph
            pointPen = DigestPointPen()
            glyph.drawPoints(pointPen)
            oldDigest = pointPen.getDigest()
            
            # Check the advance width
            if glyph.width != advanceWidth:
                glyph.width = advanceWidth
                if mark == 1:
                    glyph.mark = 200
            
            # If the digests don't match, rebuild components
            if oldDigest is not newDigest:
                if saveBackup == 1:
                    backupName = glyph.name + '.bkup'
                    font.insertGlyph(glyph, name=backupName)
                glyph.clearComponents()
                count = 0
                while count < len(components):
                    component, x, y = components[count]
                    glyph.appendComponent(component, offset=(x,y))
                    count = count+1
                if mark == 1:
                    glyph.mark = 200
            
            # Clean up things
            glyph.update()
            bar.tick(tick)
            tick = tick+1
        
        # If the glyph is not in the font, build a new glyph
        else:
            font.newGlyph(glyphName, clear=True)
            glyph = font[glyphName]
            glyph.width = advanceWidth
            count = 0
            while count < len(components):
                component, x, y = components[count]
                glyph.appendComponent(component, offset=(x,y))
                count = count+1
            if mark == 1:
                glyph.mark = 300
            glyph.update()
            bar.tick(tick)
            tick = tick+1
    bar.close()

"""
checkGlyphs takes in a font and a glyphList. It checks to see if the the components in the glyph list are in the font. 
It returns a list of missing components. The list is empty if all components are present in a font.
"""
def checkGlyphs(font, glyphList):
    missingComponents = []
    for item in glyphList:
        glyphName, advanceWidth, components = item
        for piece in components:
            component, x, y = piece
            if font.has_key(component) != True:
                missingComponents.append(component)
    return missingComponents

    
def dump(font):
    # Give the user a default name to save
    defaultName = font.info.fontName + '.txt'
    filePath = PutFile('Save dump file', defaultName)

    if filePath is not None:
        tickCount = len(font)
        bar = ProgressBar('Writing dump file', tickCount)
        tick = 0
        outList = []
        for glyph in font:
            bar.tick(tick)
            tick = tick+1
            if len(glyph.components) != 0:
                output = glyph.name + ';' + str(glyph.width)
                componentNumber = 0
                while componentNumber < len(glyph.components):
                    x, y = glyph.components[componentNumber].offset
                    output = output + ';' + glyph.components[componentNumber].baseGlyph + ';' + str(x) + ';' + str(y)
                    componentNumber = componentNumber + 1
                output = output + '\n'
                outList.append((glyph.index, output))

        # Create a dictionary for sorting the glyphs by GID
        outDictionary = dict(outList)
        outKeys = outDictionary.keys()
        outKeys.sort()
        
        # Write out the file
        file = open(filePath, 'w')
        keyCount = 0
        while keyCount < len(outKeys):
            file.write(outDictionary[outKeys[keyCount]])
            keyCount = keyCount + 1
        file.close()
        bar.close()
        Message('Dump file written')
        
def fuse(font):
    readGlyphList = getDataFile('Choose a dump file')
    if readGlyphList is not None:
        # Check to make sure that all compontents are present in the font
        checkedGlyphList = checkGlyphs(font, readGlyphList)
        if len(checkedGlyphList) == 0:
            mark = AskYesNoCancel('Do you wish to mark changed glyphs?')
            if mark != -1:
                saveBackup = AskYesNoCancel('Do you want a backup of changed glyphs?')
                if saveBackup != -1:
                    makeGlyph(readGlyphList, font, 'Updating glyphs', mark, saveBackup)
                    font.update()
                    Message('Done updating glyphs')
        else:
            # Gives a list of the components missing from the Font
            OneList(checkedGlyphList, 'Sorry, your Font is missing:')

#Script
font = CurrentFont()
try:
    do = TwoChecks('Dump components', 'Fuse components', 'Dump/Fuse')
except PendingDeprecationWarning:
    from dialogKit import ModalDialog, CheckBox
    
    class TwoChecksDK(object):
        
        def __init__(self):
            self.w = ModalDialog((200, 120), 'Dump/Fuse', okCallback=self.okCallback)
            self.w.dumpComp = CheckBox((10, 10, 180, 20), 'Dump components', callback=self.dumpCompCallback)
            self.w.fuseComp = CheckBox((10, 40, 180, 20), 'Fuse components', callback=self.fuseCompCallback, value=True)
            self.value = 2
            self.w.open()
        
        def dumpCompCallback(self, sender):
            if sender.get() == 1:
                self.value += 1
            else:
                self.value -= 1
        
        def fuseCompCallback(self, sender):
            if sender.get() == 1:
                self.value += 2
            else:
                self.value -= 2
        
        def okCallback(self, sender):
            return self.value
    
    do = TwoChecksDK().value

if do == 1:
    dump(font)
if do == 2:
    fuse(font)
if do == 3:
    dump(font)
    fuse(font)